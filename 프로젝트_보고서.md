5. 과제 연구 내용 및 결과

가. 연구내용(개발 프로그램 주요 설명)

1) 시스템 동작 환경(하드웨어 및 소프트웨어): AWS 환경에서 구동 예정

하드웨어 환경
서버: AWS EC2 인스턴스 (예상: t3.micro 또는 t3.small)
데이터베이스: AWS RDS MySQL 인스턴스
스토리지: AWS S3 (이미지 파일 저장)
로드 밸런서: AWS Application Load Balancer (선택사항)

소프트웨어 환경

프론트엔드
언어: JavaScript (ES6+)
프레임워크: React 19.1.0
빌드 도구: React Scripts 5.0.1
스타일링: CSS3, Tailwind CSS 4.1.4
라우팅: React Router DOM 6.30.0
HTTP 클라이언트: Axios 1.9.0
아이콘: React Icons 5.5.0
QR 코드: QRCode.react 4.2.0

백엔드
언어: JavaScript (Node.js)
런타임: Node.js 18.x 이상
웹 프레임워크: Express.js 4.21.2
데이터베이스: MySQL 8.0
데이터베이스 드라이버: MySQL2 3.14.1
인증: JSON Web Token (JWT) 9.0.2
암호화: Bcrypt 5.1.1
스케줄링: Node-schedule 2.1.1
환경변수: dotenv 16.5.0

개발 도구
버전 관리: Git
패키지 관리: npm
개발 서버: React Development Server (포트 3000)
API 서버: Express.js (포트 5000)

배포 환경
클라우드: Amazon Web Services (AWS)
웹 서버: Nginx (리버스 프록시)
프로세스 관리: PM2
도메인: AWS Route 53 (예상)
SSL: AWS Certificate Manager

2) 개발자 및 사용자 매뉴얼(개발자 매뉴얼은 시스템 구현 방법으로 각종 설계서, 사용자 매뉴얼은 시스템 사용 방법을 설명): 추가 예정

개발자 매뉴얼

시스템 아키텍처
본 프로젝트는 MERN 스택을 기반으로 한 풀스택 웹 애플리케이션입니다.

React Frontend (포트 3000) ←→ Express.js API (포트 5000) ←→ MySQL DB (AWS RDS)
         ↓                       ↓
   AWS S3 (이미지 저장)      Node-schedule (스케줄러)

데이터베이스 설계
users: 사용자 정보 (user_id, username, password, name, phone, email, role)
product: 상품 정보 (product_id, product_name, price, image_url, product_type, stock_quantity, is_active)
book: 도서 상세 정보 (book_id, product_id, author, publisher, category)
orders: 주문 정보 (order_id, user_id, status, order_date, total_amount, phone)
order_items: 주문 상품 목록 (order_item_id, order_id, product_id, quantity, price_per_item)
receipts: 수령 정보 (receipt_id, order_id, receipt_status, payment_date, receipt_date)
questions: 문의사항 (question_id, user_id, question, answer, passwd, created_at)

API 엔드포인트 설계
POST /api/register          - 회원가입
POST /api/login             - 로그인
POST /api/check-username    - 아이디 중복확인
GET  /api/me               - 사용자 정보 조회
PUT  /api/change-password  - 비밀번호 변경
DELETE /api/withdraw       - 회원탈퇴

GET  /api/data             - 상품 목록 조회
GET  /api/search           - 상품 검색
GET  /api/categories       - 카테고리 조회
GET  /api/recommended-books - 추천 도서

POST /api/cart             - 장바구니 추가
GET  /api/cart             - 장바구니 조회
PUT  /api/cart/item/:id    - 장바구니 수량 변경
DELETE /api/cart/item/:id  - 장바구니 아이템 삭제

POST /api/complete-order   - 주문 완료
GET  /api/order-details/:id - 주문 상세 조회
GET  /api/order-stats      - 주문 통계
GET  /api/reservation      - 예약내역 조회

POST /api/questions        - 문의 등록
GET  /api/questions        - 문의 목록 조회
PUT  /api/questions/:id/answer - 문의 답변

보안 구현
JWT 토큰 기반 인증
Bcrypt를 이용한 비밀번호 해싱
CORS 설정으로 크로스 오리진 요청 제어
Express-session을 이용한 세션 관리
관리자 권한 검증 미들웨어

스케줄러 기능
매일 자정에 7일 경과된 미결제 장바구니 자동 삭제
매일 자정에 7일 경과된 미수령 주문 자동 취소
개발 환경에서는 30초마다 1분 경과된 데이터 처리

사용자 매뉴얼

회원가입 및 로그인
1. 회원가입 시 아이디, 비밀번호, 이름, 전화번호, 이메일 입력
2. 아이디 중복 확인 기능 제공
3. 로그인 후 JWT 토큰으로 세션 유지

상품 탐색 및 검색
1. 메인 페이지에서 상품 탐색 버튼 클릭
2. 카테고리별 필터링 (전기/전자, 컴퓨터, 치의학 등)
3. 상품 타입별 필터링 (책, 문구류)
4. 정렬 옵션 (최신순, 낮은가격순, 높은가격순)
5. 검색 기능으로 상품명 기반 검색

장바구니 및 주문
1. 상품 상세 페이지에서 수량 선택 후 장바구니 추가
2. 장바구니에서 수량 변경 및 아이템 삭제 가능
3. 주문 완료 시 재고 확인 후 주문 처리
4. 주문 완료 후 QR 코드 생성

예약 및 수령
1. 마이페이지에서 주문 내역 조회
2. 예약 페이지에서 전화번호 뒷자리로 주문 조회
3. QR 코드 스캔으로 주문 상세 확인
4. 관리자가 수령 완료 처리

문의사항
1. 로그인 후 문의 등록 가능
2. 비밀번호 설정으로 답변 열람
3. 관리자가 답변 등록

3) 중요 소스 코드(모든 소스코드가 아니라 중요 기능에 대한 소스코드만 간략히 설명)

1. 인증 미들웨어 (JWT 토큰 검증)

server.js - JWT 인증 미들웨어
const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: '로그인이 필요합니다.' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    const db = await initDB();
    const [users] = await db.query('SELECT user_id, username, role FROM users WHERE user_id = ?', [decoded.userId]);
    await db.end();
    
    if (users.length === 0) {
      return res.status(401).json({ error: '사용자를 찾을 수 없습니다.' });
    }
    
    req.user = users[0];
    next();
  } catch (err) {
    return res.status(403).json({ error: '유효하지 않은 토큰입니다.' });
  }
};

이 코드는 JWT 토큰을 검증하고 사용자 정보를 요청 객체에 추가하는 미들웨어입니다. 모든 보호된 API 엔드포인트에서 사용됩니다.

2. 장바구니 추가 기능

server.js - 장바구니에 상품 추가
app.post('/api/cart', authenticateToken, async (req, res) => {
  const { product_id, quantity } = req.body;
  const userId = req.user.user_id;

  try {
    const db = await initDB();

    // 준비 상태 주문 확인
    const [orderResults] = await db.query(
      `SELECT order_id FROM orders WHERE user_id = ? AND status = '준비' LIMIT 1`,
      [userId]
    );

    let order_id;
    if (orderResults.length === 0) {
      const [insertOrder] = await db.query(
        `INSERT INTO orders (status, user_id) VALUES ('준비', ?)`,
        [userId]
      );
      order_id = insertOrder.insertId;
    } else {
      order_id = orderResults[0].order_id;
    }

    // 상품 가격 조회 및 장바구니 아이템 처리
    const [productResults] = await db.query(
      `SELECT price FROM product WHERE product_id = ?`,
      [product_id]
    );
    const price_per_item = productResults[0]?.price;

    // 기존 아이템 확인 후 업데이트 또는 새로 추가
    const [itemResults] = await db.query(
      `SELECT order_item_id, quantity FROM order_items
       WHERE order_id = ? AND product_id = ?`,
      [order_id, product_id]
    );

    if (itemResults.length > 0) {
      const newQuantity = itemResults[0].quantity + quantity;
      await db.query(
        `UPDATE order_items SET quantity = ? WHERE order_item_id = ?`,
        [newQuantity, itemResults[0].order_item_id]
      );
    } else {
      await db.query(
        `INSERT INTO order_items (order_id, product_id, quantity, price_per_item)
         VALUES (?, ?, ?, ?)`,
        [order_id, product_id, quantity, price_per_item]
      );
    }

    await db.end();
    res.status(200).json({ message: '장바구니에 상품 추가됨' });
  } catch (err) {
    console.error('장바구니 추가 오류:', err);
    res.status(500).json({ error: '장바구니 추가 실패' });
  }
});

이 코드는 사용자가 상품을 장바구니에 추가할 때 실행됩니다. 기존에 '준비' 상태의 주문이 있으면 그것을 사용하고, 없으면 새로 생성합니다.

3. 주문 완료 처리

server.js - 결제 완료 처리
app.post('/api/complete-order', authenticateToken, async (req, res) => {
  const userId = req.user.user_id;

  try {
    const db = await initDB();

    // 준비 상태 주문 조회
    const [orderRow] = await db.query(`
      SELECT order_id FROM orders
      WHERE user_id = ? AND status = '준비'
      LIMIT 1
    `, [userId]);

    if (!orderRow || orderRow.length === 0) {
      await db.end();
      return res.status(400).json({ success: false, error: '주문이 없습니다.' });
    }

    const orderId = orderRow[0].order_id;

    // 재고 확인
    const [items] = await db.query(`
      SELECT oi.product_id, oi.quantity, p.stock_quantity, p.product_name
      FROM order_items oi
      JOIN product p ON oi.product_id = p.product_id
      WHERE oi.order_id = ?
    `, [orderId]);

    for (const item of items) {
      if (item.quantity > item.stock_quantity) {
        await db.end();
        return res.status(400).json({
          success: false,
          error: `${item.product_name}의 재고가 부족합니다. 현재 재고: ${item.stock_quantity}개`
        });
      }
    }

    // 주문 상태를 '완료'로 변경
    await db.query(`
      UPDATE orders
      SET status = '완료',
          order_date = CURRENT_TIMESTAMP
      WHERE order_id = ?
    `, [orderId]);

    // 재고 차감
    for (const item of items) {
      await db.query(`
        UPDATE product
        SET stock_quantity = stock_quantity - ?
        WHERE product_id = ?
      `, [item.quantity, item.product_id]);

      // 재고가 0이 되면 상품 비활성화
      await db.query(`
        UPDATE product
        SET is_active = CASE 
                          WHEN stock_quantity = 0 THEN 'false'
                          ELSE 'true'
                        END
        WHERE product_id = ?
      `, [item.product_id]);
    }

    // 총 금액 계산 및 업데이트
    const [sumResult] = await db.query(`
      SELECT SUM(quantity * price_per_item) AS total FROM order_items WHERE order_id = ?
    `, [orderId]);
    const totalAmount = sumResult[0].total || 0;

    await db.query(
      `UPDATE orders SET total_amount = ? WHERE order_id = ?`,
      [totalAmount, orderId]
    );

    // 수령 정보 생성
    await db.query(`
      INSERT INTO receipts (order_id, receipt_status, payment_date)
      VALUES (?, '대기', CURRENT_TIMESTAMP)
      ON DUPLICATE KEY UPDATE receipt_status = '대기',
      payment_date = CURRENT_TIMESTAMP
    `, [orderId]);

    res.json({ success: true, orderId });
    await db.end();
  } catch (err) {
    console.error('주문 상태 업데이트 오류:', err);
    res.status(500).json({ success: false, error: '서버 오류' });
  }
});

이 코드는 사용자가 주문을 완료할 때 실행되며, 재고 확인, 주문 상태 변경, 재고 차감, 수령 정보 생성을 순차적으로 처리합니다.

4. 자동 스케줄러 기능

server.js - 장바구니 자동 삭제 스케줄러
schedule.scheduleJob('0 0 * * *', async () => {
  try {
    const db = await initDB();

    // 7일 전의 준비 상태 주문 조회
    const [rows] = await db.query(`
      SELECT order_id FROM orders
      WHERE status = '준비'
        AND order_date < (NOW() - INTERVAL 7 DAY)
    `);

    if (rows.length > 0) {
      const orderIds = rows.map(row => row.order_id);

      // order_items 먼저 삭제
      const [deletedItems] = await db.query(
        `DELETE FROM order_items WHERE order_id IN (?)`,
        [orderIds]
      );

      // orders 삭제
      const [deletedOrders] = await db.query(
        `DELETE FROM orders WHERE order_id IN (?)`,
        [orderIds]
      );

      console.log(`7일 경과 장바구니 order_items ${deletedItems.affectedRows}건 삭제됨`);
      console.log(`7일 경과 장바구니 orders ${deletedOrders.affectedRows}건 삭제됨`);
    }

    await db.end();
  } catch (err) {
    console.error('장바구니 자동 삭제 실패:', err);
  }
});

이 코드는 매일 자정에 실행되어 7일 이상 결제하지 않은 장바구니를 자동으로 삭제합니다.

5. React 컴포넌트 구조 (App.js)

App.js - 메인 라우팅 컴포넌트
function App() {
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <Router>
      <div className="App">
        <Routes>
          <Route path="/" element={<MainPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          <Route path="/mypage" element={<MyPage />} />
          <Route path="/book" element={isMobile ? <M_BookPage /> : <BookPage />} />
          <Route path="/cart" element={isMobile ? <M_CartPage /> : <CartPage />} />
          <Route path="/order-details/:orderId" element={isMobile ? <M_OrderDetails /> : <OrderDetails />} />
          <Route path="/reservation" element={isMobile ? <M_ReservationPage /> : <ReservationPage />} />
          <Route path="/inquiry" element={isMobile ? <M_InquiryPage /> : <InquiryPage />} />
        </Routes>
      </div>
    </Router>
  );
}

이 코드는 반응형 웹 디자인을 구현하여 화면 크기에 따라 데스크톱용 컴포넌트와 모바일용 컴포넌트를 자동으로 전환합니다.

6. 데이터베이스 연결 설정

db.js - MySQL 데이터베이스 연결
const mysql = require('mysql2/promise');
require('dotenv').config();

async function initDB() {
  const connection = await mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
  });
  return connection;
}

module.exports = initDB;

이 코드는 환경변수를 사용하여 MySQL 데이터베이스에 연결하는 함수입니다. AWS RDS에 배포할 때는 해당 환경변수들을 설정해야 합니다.

시스템 특징 및 혁신성

1. 반응형 웹 디자인
화면 크기에 따라 자동으로 데스크톱/모바일 컴포넌트 전환
모든 기능이 모바일과 데스크톱에서 동일하게 작동

2. 실시간 재고 관리
주문 시 재고 자동 차감
재고 부족 시 주문 차단
재고가 0이 되면 상품 자동 비활성화

3. QR 코드 기반 주문 관리
주문 완료 시 QR 코드 자동 생성
QR 코드 스캔으로 주문 상세 정보 확인
수령 관리 시스템과 연동

4. 자동화된 데이터 관리
7일 경과 미결제 장바구니 자동 삭제
7일 경과 미수령 주문 자동 취소
스케줄러를 통한 시스템 자동 관리

5. 보안 강화
JWT 토큰 기반 인증
Bcrypt 해싱을 통한 비밀번호 보호
관리자 권한 검증 시스템

6. 사용자 친화적 인터페이스
직관적인 네비게이션
실시간 검색 및 필터링
반응형 UI/UX

7. 기대효과 및 개선방향

기대효과

사용자 편의성 향상
반응형 웹 디자인으로 모바일과 데스크톱에서 동일한 사용자 경험 제공
QR 코드를 통한 간편한 주문 확인 및 수령 관리
실시간 재고 확인으로 품절 상품 주문 방지
직관적인 인터페이스로 사용자 학습 비용 최소화

운영 효율성 증대
자동화된 스케줄러를 통한 시스템 관리 부담 감소
실시간 재고 관리로 재고 부족 상황 사전 예방
관리자 대시보드를 통한 주문 현황 실시간 모니터링
전화번호 뒷자리 기반 예약 조회로 고객 서비스 향상

비즈니스 가치 창출
온라인 쇼핑몰 구축으로 매장 운영 시간 제약 해결
24시간 주문 접수 가능으로 매출 증대 기대
고객 데이터 수집을 통한 마케팅 전략 수립 기반 마련
확장 가능한 아키텍처로 향후 기능 추가 용이

개선방향

기능적 개선사항
결제 시스템 연동 (카드 결제, 간편결제 등)
상품 리뷰 및 평점 시스템 도입
개인화된 추천 알고리즘 구현
재고 알림 서비스 (SMS, 이메일)
주문 취소 및 환불 처리 시스템
고객 상담 채팅봇 도입

기술적 개선사항
Redis 캐싱 시스템 도입으로 성능 최적화
Elasticsearch를 활용한 고급 검색 기능
이미지 최적화 및 CDN 도입
API 문서화 및 테스트 코드 작성
로그 분석 시스템 구축
모니터링 및 알림 시스템 도입

보안 강화
HTTPS 강제 적용
SQL Injection 방어 강화
Rate Limiting 도입
사용자 입력 데이터 검증 강화
보안 헤더 설정
정기적인 보안 취약점 점검

사용자 경험 개선
다크 모드 지원
접근성(Accessibility) 향상
다국어 지원
PWA(Progressive Web App) 기능 추가
오프라인 모드 지원
성능 최적화로 페이지 로딩 속도 개선

확장성 및 유지보수성
마이크로서비스 아키텍처로 전환 검토
컨테이너화(Docker) 및 Kubernetes 도입
CI/CD 파이프라인 구축
코드 품질 관리 도구 도입
데이터베이스 최적화 및 샤딩 고려
클라우드 네이티브 서비스 활용 확대

결론

본 프로젝트는 현대적인 웹 기술을 활용하여 도서 및 문구류 온라인 쇼핑몰을 구현했습니다. React와 Express.js를 기반으로 한 풀스택 애플리케이션으로, 반응형 디자인, 실시간 재고 관리, QR 코드 기반 주문 관리, 자동화된 데이터 관리 등 다양한 혁신적인 기능을 포함하고 있습니다.

AWS 클라우드 환경에서의 배포를 고려하여 설계되었으며, 확장성과 유지보수성을 고려한 아키텍처로 구성되어 있습니다. 사용자와 관리자 모두에게 편리한 인터페이스를 제공하며, 안전하고 효율적인 전자상거래 시스템을 구현했습니다.

앞으로 제시된 개선방향을 통해 더욱 완성도 높은 서비스로 발전시켜 나갈 계획이며, 지속적인 사용자 피드백 수집과 기술 발전에 따른 업데이트를 통해 경쟁력 있는 온라인 쇼핑몰로 성장할 것으로 기대됩니다.
