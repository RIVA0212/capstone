1. 인증 미들웨어 (JWT 토큰 검증)

const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: '로그인이 필요합니다.' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    const db = await initDB();
    const [users] = await db.query('SELECT user_id, username, role FROM users WHERE user_id = ?', [decoded.userId]);
    await db.end();
    
    if (users.length === 0) {
      return res.status(401).json({ error: '사용자를 찾을 수 없습니다.' });
    }
    
    req.user = users[0];
    next();
  } catch (err) {
    return res.status(403).json({ error: '유효하지 않은 토큰입니다.' });
  }
};

이 코드는 JWT 토큰을 검증하고 사용자 정보를 요청 객체에 추가하는 미들웨어입니다. 모든 보호된 API 엔드포인트에서 사용됩니다.

2. 장바구니 추가 기능

app.post('/api/cart', authenticateToken, async (req, res) => {
  const { product_id, quantity } = req.body;
  const userId = req.user.user_id;

  try {
    const db = await initDB();

    // 준비 상태 주문 확인
    const [orderResults] = await db.query(
      `SELECT order_id FROM orders WHERE user_id = ? AND status = '준비' LIMIT 1`,
      [userId]
    );

    let order_id;
    if (orderResults.length === 0) {
      const [insertOrder] = await db.query(
        `INSERT INTO orders (status, user_id) VALUES ('준비', ?)`,
        [userId]
      );
      order_id = insertOrder.insertId;
    } else {
      order_id = orderResults[0].order_id;
    }

    // 상품 가격 조회 및 장바구니 아이템 처리
    const [productResults] = await db.query(
      `SELECT price FROM product WHERE product_id = ?`,
      [product_id]
    );
    const price_per_item = productResults[0]?.price;

    // 기존 아이템 확인 후 업데이트 또는 새로 추가
    const [itemResults] = await db.query(
      `SELECT order_item_id, quantity FROM order_items
       WHERE order_id = ? AND product_id = ?`,
      [order_id, product_id]
    );

    if (itemResults.length > 0) {
      const newQuantity = itemResults[0].quantity + quantity;
      await db.query(
        `UPDATE order_items SET quantity = ? WHERE order_item_id = ?`,
        [newQuantity, itemResults[0].order_item_id]
      );
    } else {
      await db.query(
        `INSERT INTO order_items (order_id, product_id, quantity, price_per_item)
         VALUES (?, ?, ?, ?)`,
        [order_id, product_id, quantity, price_per_item]
      );
    }

    await db.end();
    res.status(200).json({ message: '장바구니에 상품 추가됨' });
  } catch (err) {
    console.error('장바구니 추가 오류:', err);
    res.status(500).json({ error: '장바구니 추가 실패' });
  }
});

이 코드는 사용자가 상품을 장바구니에 추가할 때 실행됩니다. 기존에 '준비' 상태의 주문이 있으면 그것을 사용하고, 없으면 새로 생성합니다.

3. 주문 완료 처리

app.post('/api/complete-order', authenticateToken, async (req, res) => {
  const userId = req.user.user_id;

  try {
    const db = await initDB();

    // 준비 상태 주문 조회
    const [orderRow] = await db.query(`
      SELECT order_id FROM orders
      WHERE user_id = ? AND status = '준비'
      LIMIT 1
    `, [userId]);

    if (!orderRow || orderRow.length === 0) {
      await db.end();
      return res.status(400).json({ success: false, error: '주문이 없습니다.' });
    }

    const orderId = orderRow[0].order_id;

    // 재고 확인
    const [items] = await db.query(`
      SELECT oi.product_id, oi.quantity, p.stock_quantity, p.product_name
      FROM order_items oi
      JOIN product p ON oi.product_id = p.product_id
      WHERE oi.order_id = ?
    `, [orderId]);

    for (const item of items) {
      if (item.quantity > item.stock_quantity) {
        await db.end();
        return res.status(400).json({
          success: false,
          error: `${item.product_name}의 재고가 부족합니다. 현재 재고: ${item.stock_quantity}개`
        });
      }
    }

    // 주문 상태를 '완료'로 변경
    await db.query(`
      UPDATE orders
      SET status = '완료',
          order_date = CURRENT_TIMESTAMP
      WHERE order_id = ?
    `, [orderId]);

    // 재고 차감
    for (const item of items) {
      await db.query(`
        UPDATE product
        SET stock_quantity = stock_quantity - ?
        WHERE product_id = ?
      `, [item.quantity, item.product_id]);

      // 재고가 0이 되면 상품 비활성화
      await db.query(`
        UPDATE product
        SET is_active = CASE 
                          WHEN stock_quantity = 0 THEN 'false'
                          ELSE 'true'
                        END
        WHERE product_id = ?
      `, [item.product_id]);
    }

    // 총 금액 계산 및 업데이트
    const [sumResult] = await db.query(`
      SELECT SUM(quantity * price_per_item) AS total FROM order_items WHERE order_id = ?
    `, [orderId]);
    const totalAmount = sumResult[0].total || 0;

    await db.query(
      `UPDATE orders SET total_amount = ? WHERE order_id = ?`,
      [totalAmount, orderId]
    );

    // 수령 정보 생성
    await db.query(`
      INSERT INTO receipts (order_id, receipt_status, payment_date)
      VALUES (?, '대기', CURRENT_TIMESTAMP)
      ON DUPLICATE KEY UPDATE receipt_status = '대기',
      payment_date = CURRENT_TIMESTAMP
    `, [orderId]);

    res.json({ success: true, orderId });
    await db.end();
  } catch (err) {
    console.error('주문 상태 업데이트 오류:', err);
    res.status(500).json({ success: false, error: '서버 오류' });
  }
});

이 코드는 사용자가 주문을 완료할 때 실행되며, 재고 확인, 주문 상태 변경, 재고 차감, 수령 정보 생성을 순차적으로 처리합니다.

4. 자동 스케줄러 기능

schedule.scheduleJob('0 0 * * *', async () => {
  try {
    const db = await initDB();

    // 7일 전의 준비 상태 주문 조회
    const [rows] = await db.query(`
      SELECT order_id FROM orders
      WHERE status = '준비'
        AND order_date < (NOW() - INTERVAL 7 DAY)
    `);

    if (rows.length > 0) {
      const orderIds = rows.map(row => row.order_id);

      // order_items 먼저 삭제
      const [deletedItems] = await db.query(
        `DELETE FROM order_items WHERE order_id IN (?)`,
        [orderIds]
      );

      // orders 삭제
      const [deletedOrders] = await db.query(
        `DELETE FROM orders WHERE order_id IN (?)`,
        [orderIds]
      );

      console.log(`7일 경과 장바구니 order_items ${deletedItems.affectedRows}건 삭제됨`);
      console.log(`7일 경과 장바구니 orders ${deletedOrders.affectedRows}건 삭제됨`);
    }

    await db.end();
  } catch (err) {
    console.error('장바구니 자동 삭제 실패:', err);
  }
});

이 코드는 매일 자정에 실행되어 7일 이상 결제하지 않은 장바구니를 자동으로 삭제합니다.

5. React 컴포넌트 구조 (App.js)

function App() {
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <Router>
      <div className="App">
        <Routes>
          <Route path="/" element={<MainPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          <Route path="/mypage" element={<MyPage />} />
          <Route path="/book" element={isMobile ? <M_BookPage /> : <BookPage />} />
          <Route path="/cart" element={isMobile ? <M_CartPage /> : <CartPage />} />
          <Route path="/order-details/:orderId" element={isMobile ? <M_OrderDetails /> : <OrderDetails />} />
          <Route path="/reservation" element={isMobile ? <M_ReservationPage /> : <ReservationPage />} />
          <Route path="/inquiry" element={isMobile ? <M_InquiryPage /> : <InquiryPage />} />
        </Routes>
      </div>
    </Router>
  );
}

이 코드는 반응형 웹 디자인을 구현하여 화면 크기에 따라 데스크톱용 컴포넌트와 모바일용 컴포넌트를 자동으로 전환합니다.

6. 데이터베이스 연결 설정

const mysql = require('mysql2/promise');
require('dotenv').config();

async function initDB() {
  const connection = await mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
  });
  return connection;
}

module.exports = initDB;

이 코드는 환경변수를 사용하여 MySQL 데이터베이스에 연결하는 함수입니다. AWS RDS에 배포할 때는 해당 환경변수들을 설정해야 합니다.
